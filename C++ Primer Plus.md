# C++ Primer Plus
## 类和对象
封装：将实现细节放在一起并将它们与抽象分开。数据隐藏、类函数定义和类声明放在不同的文件中。

数据隐藏：将数据放在类的私有部分中。

类和结构：C++ 对结构进行了扩展，使之具有与类相同的特性。它们之间的唯一区别是，结构默认访问类型是 public，而类为 private。C++ 程序员通常使用类来实现类描述，而把结构限制为只表示纯粹的数据对象。

类成员函数：函数头、函数体，返回类型、参数。作用域解析运算符（::） 来指出函数所属的类

this：this 指针指向用来调用成员函数的对象（this 被作为隐藏参数传递给方法）。每个成员函数（包括构造函数和析构函数）都有一个 this 指针。

派生类构造函数：创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数。基类构造函数负责初始化继承的数据成员；派生类构造函数主要用于初始化新增的数据成员。派生类的构造函数总是调用一个基类的构造函数。可以使用初始化列表语法指明要使用的基类构造函数，否则将使用默认的基类构造函数。

派生类析构函数：程序将首先调用派生类析构函数，然后再调用基类析构函数。

虚函数：

- 在基类方法的声明中使用关键字 Virtual 可使该方法在基类以及所有的派生类（包括从派生类派生出来的类）中是虚的。
- 如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为动态联编或晚期联编。这种行为非常重要，因为这样基类指针或引用可以指向派生类对象。
- 如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚的。
- 构造函数不能是虚函数。
- 析构函数应当是虚函数，除非类不用做基类。
- 友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函数。
- derived 没有重新定义函数，将使用该函数的 base 版本。
- 重新定义将隐藏方法。

protected：只有在基类派生的类中才会表现出来。派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。
- 最好对数据成员采用私有访问控制，不要使用保护访问控制
- 对于成员函数，保护访问控制很有用，他让派生类能够访问公众不能使用的成员函数。

explicit：只有一个参数的构造函数也定义了一个隐式转换，将该构造函数对应数据类型的数据转换为该类对象。只对构造函数起作用，用来抑制隐式转换。

::作用域：
- 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间
- 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的
- 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的

前置声明：过继承的方式是不能使用前置声明的、这个说明直接定义对象，不是指针或者引用的方式也不能采用前置声明的方式、实现文件中，直接new对象，也是不能采用前置声明，因为需要知道对象占据的内存大小。类中数据成员直接声明的是对象指针的方式是可以的。前置声明可以带来编译时间的优化，但会导致其它问题。默认采用#include。
